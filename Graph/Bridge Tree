// return component id for each node in the bridge tree
vector<int> Brige_tree(int n, vector<vector<int>> &g) {
  int timer = 0;
  vector<bool> vis(n, false);
  vector<int> tin(n, -1), low(n, -1);
  set<pair<int, int>> bridges;
  auto dfs = [&](auto &&self, int node, int pr = -1) -> void {
    vis[node] = true;
    low[node] = tin[node]= timer++;
    for (auto &son : g[node]) {
      if (son == pr) continue;
      if (!vis[son]) {
        self(self, son, node);
        low[node] = min(low[node], low[son]);
        if (low[son] > tin[node]) {
          bridges.emplace(min(node, son), max(node, son));
        }
      } else {
        low[node] = min(low[node], tin[son]);
      }
    }
  };
  for (int i = 0; i < n; i++) {
    if (!vis[i]) {
      dfs(dfs, i);
    }
  }
  vector<int> which_comp(n, -1);
  auto dfs2 = [&](auto &&self, int node, int which) -> void {
    which_comp[node] = which;
    for (auto &son : g[node]) {
      if (which_comp[son] == -1) {
        if (bridges.count({min(node, son), max(node, son)}) == 0) {
          self(self, son, which);
        }
      }
    }
  };
  int id = 0;
  for (int i = 0; i < n; i++) {
    if (which_comp[i] == -1) {
      dfs2(dfs2, i, id++);
    }
  }
  return which_comp;
}
