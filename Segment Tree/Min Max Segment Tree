struct MinMaxSegTree {
  int n;
  vector<array<int, 2>> tree;

  MinMaxSegTree(int size) {
    n = size;
    tree.resize(n << 2, {INT_MAX, INT_MIN});
  }

  void build(const vector<int> &arr, int node, int start, int end) {
    if (start == end) {
      tree[node][0] = arr[start];
      tree[node][1] = arr[start];
    } else {
      int mid = (start + end) >> 1;
      build(arr, node << 1, start, mid);
      build(arr, (node << 1) | 1, mid + 1, end);
      tree[node][0] = min(tree[node << 1][0], tree[(node << 1) | 1][0]);
      tree[node][1] = max(tree[node << 1][1], tree[(node << 1) | 1][1]);
    }
  }

  pair<int, int> query(int node, int start, int end, int l, int r) {
    if (l > end || r < start) {
      return {INT_MAX, INT_MIN};
    }
    if (l <= start && r >= end) {
      return {tree[node][0], tree[node][1]};
    }
    int mid = (start + end) >> 1;
    auto leftRes = query(node << 1, start, mid, l, r);
    auto rightRes = query((node << 1) | 1, mid + 1, end, l, r);
    return {min(leftRes.first, rightRes.first), max(leftRes.second, rightRes.second)};
  }

  void update(int node, int start, int end, int idx, int val) {
    if (start == end) {
      tree[node][0] = val;
      tree[node][1] = val;
    } else {
      int mid = (start + end) >> 1;
      if (idx <= mid) {
        update(node << 1, start, mid, idx, val);
      } else {
        update((node << 1) | 1, mid + 1, end, idx, val);
      }
      tree[node][0] = min(tree[node << 1][0], tree[(node << 1) | 1][0]);
      tree[node][1] = max(tree[node << 1][1], tree[(node << 1) | 1][1]);
    }
  }

  void build(const vector<int> &arr) { build(arr, 1, 0, n - 1); }
  int maxQry(int l, int r) { return query(1, 0, n - 1, l, r).second; }
  int minQry(int l, int r) { return query(1, 0, n - 1, l, r).first; }
  pair<int, int> bothQry(int l, int r) { return query(1, 0, n - 1, l, r); }
  void pointUpdate(int idx, int val) { update(1, 0, n - 1, idx, val); }
};
