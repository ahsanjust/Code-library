struct Bitset {
  /// Author: Neal Wu (neal)
  vector<uint64_t> bits;
  int64_t b, n;
 
  Bitset(int64_t _b = 0) {
    init(_b);
  }
  void init(int64_t _b) {
    b = _b;
    n = (b + 63) / 64;
    bits.assign(n, 0);
  }
  void clear() {
    b = n = 0;
    bits.clear();
  }
  void reset() {
    bits.assign(n, 0);
  }
  void _clean() {
    // Reset all bits after `b`.
    if (b != 64 * n) {
        bits.back() &= (1LLU << (b - 64 * (n - 1))) - 1;
    }
  }
 
  int count() const {
    int cnt = 0;
    for (int i = 0; i < n; i++) {
      cnt += __builtin_popcountll(bits[i]);
    }
    return cnt;
  }
 
  bool get(int64_t index) const {
    return bits[index / 64] >> (index % 64) & 1;
  }
 
  void set(int64_t index, bool value) {
    assert(0 <= index && index < b);
    bits[index / 64] &= ~(1LLU << (index % 64));
    bits[index / 64] |= uint64_t(value) << (index % 64);
  }
 
  bool check_range(int64_t l, int64_t r) {
    assert(0 <= l && l <= r && r < b);
    int64_t li = l / 64, ri = r / 64;
    int64_t lo = l % 64, ro = r % 64;
    if (li == ri) {
      uint64_t left_mask = (~0LLU) << lo;
      uint64_t right_mask = (ro == 63 ? ~0LLU : ((1LLU << (ro + 1)) - 1));
      uint64_t mask = left_mask & right_mask;
      return (bits[li] & mask) != 0;
    }
    if ((bits[li] & ((~0LLU) << lo)) != 0) return true;
    for (int64_t i = li + 1; i < ri; ++i) {
      if (bits[i]) return true;
    }
    uint64_t last_mask = (ro == 63 ? ~0LLU : ((1LLU << (ro + 1)) - 1));
    return (bits[ri] & last_mask) != 0;
  }
 
  // Simulates `bs |= bs << shift;`
  void or_shift(int64_t shift) {
    int64_t div = shift / 64, mod = shift % 64;
    if (mod == 0) {
      for (int64_t i = n - 1; i >= div; i--) {
        bits[i] |= bits[i - div];
      }
      return;
    }
    for (int64_t i = n - 1; i >= div + 1; i--) {
      bits[i] |= bits[i - (div + 1)] >> (64 - mod) | bits[i - div] << mod;
    }
    if (div < n) {
      bits[div] |= bits[0] << mod;
    }
    _clean();
  }
 
  // Simulates `bs |= bs >> shift;`
  void or_shift_down(int64_t shift) {
    int64_t div = shift / 64, mod = shift % 64;
    if (mod == 0) {
      for (int64_t i = div; i < n; i++) {
        bits[i - div] |= bits[i];
      }
      return;
    }
    for (int64_t i = 0; i < n - (div + 1); i++) {
      bits[i] |= bits[i + (div + 1)] << (64 - mod) | bits[i + div] >> mod;
    }
    if (div < n) {
      bits[n - div - 1] |= bits[n - 1] >> mod;
    }
    _clean();
  }

  int64_t find_first() const {
    for (int i = 0; i < n; i++) {
      if (bits[i] != 0) {
        return 64 * i + __builtin_ctzll(bits[i]);
      }
    }
    return -1;
  }
  
  Bitset& operator&=(const Bitset &other) {
    assert(b == other.b);
    for (int i = 0; i < n; i++) {
      bits[i] &= other.bits[i];
    }
    return *this;
  }
};
