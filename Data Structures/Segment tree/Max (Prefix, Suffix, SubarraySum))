struct info {
  int64_t sum;
  int64_t mxp;
  int64_t mxs;
  int64_t mxsub;
  info() : sum(0), mxp(-1e17), mxs(-1e17), mxsub(-1e17) {}
  info(int v) {
    sum = mxp = mxs = mxsub = v;
  }
};

info merge(const info &a, const info &b) {
  info res = info();
  res.sum = a.sum + b.sum;
  res.mxp = max(a.mxp, a.sum + b.mxp);
  res.mxs = max(b.mxs, b.sum + a.mxs);
  res.mxsub = max({a.mxsub, b.mxsub, a.mxs + b.mxp});
  return res;
}

struct ST {
  int _n;
  vector<info> t;
  ST(int size = 0) {
    _n = size;
    t.resize(_n << 2);
  }

  void build(int node, int s, int e, const vector<int> &a) {
    if (s == e) {
      t[node] = info(a[s]);
      return;
    }
    int m = (s + e) >> 1;
    build(node << 1, s, m, a);
    build(node << 1 | 1, m + 1, e, a);
    t[node] = merge(t[node << 1], t[node << 1 | 1]);
  }

  info query(int node, int s, int e, int l, int r) {
    if (r < s || e < l) return info();
    if (l <= s && e <= r) return t[node];
    int m = (s + e) >> 1;
    info left = query(node << 1, s, m, l, r);
    info right = query(node << 1 | 1, m + 1, e, l, r);
    return merge(left, right);
  }
  void update(int n, int s, int e, int p, info &v) {
    if (s == e) {
      t[n] = v;
      return;
    }
    int m = (s + e) >> 1;
    if (p <= m) update(n << 1, s, m, p, v);
    else update(n << 1 | 1, m + 1, e, p, v);
    t[n] = merge(t[n << 1], t[n << 1 | 1]);
  }
  void build(const vector<int> &a) {
    _n = (int)a.size();
    if (_n == 0) return;
    t.assign(_n << 2, info());
    build(1, 0, _n - 1, a);
  }
  void update(int p, info v) {
    update(1, 0, _n - 1, p, v);
  }
  info query(int l, int r) {
    if (_n == 0 || l > r) return info();
    return query(1, 0, _n - 1, l, r);
  }
};
