struct info {
  int64_t sum;
  int64_t maxPrefix;
  int64_t maxSuffix;
  int64_t maxSubarray;
  info() : sum(0), maxPrefix(-1e17), maxSuffix(-1e17), maxSubarray(-1e17) {}
  info(int v) {
    sum = maxPrefix = maxSuffix = maxSubarray = v;
  }
};

info merge(const info &a, const info &b) {
  info res = info();
  res.sum = a.sum + b.sum;
  res.maxPrefix = max(a.maxPrefix, a.sum + b.maxPrefix);
  res.maxSuffix = max(b.maxSuffix, b.sum + a.maxSuffix);
  res.maxSubarray = max({a.maxSubarray, b.maxSubarray, a.maxSuffix + b.maxPrefix});
  return res;
}

struct ST {
  int _n;
  vector<info> t;
  ST(int size = 0) {
    _n = size;
    t.resize(_n << 2);
  }

  void build(int node, int s, int e, const vector<int> &a) {
    if (s == e) {
      t[node] = info(a[s]);
      return;
    }
    int m = (s + e) >> 1;
    build(node << 1, s, m, a);
    build(node << 1 | 1, m + 1, e, a);
    t[node] = merge(t[node << 1], t[node << 1 | 1]);
  }

  info query(int node, int s, int e, int l, int r) {
    if (r < s || e < l) return info();
    if (l <= s && e <= r) return t[node];
    int m = (s + e) >> 1;
    info left = query(node << 1, s, m, l, r);
    info right = query(node << 1 | 1, m + 1, e, l, r);
    return merge(left, right);
  }
  void update(int n, int s, int e, int p, info &v) {
    if (s == e) {
      t[n] = v;
      return;
    }
    int m = (s + e) >> 1;
    if (p <= m) update(n << 1, s, m, p, v);
    else update(n << 1 | 1, m + 1, e, p, v);
    t[n] = merge(t[n << 1], t[n << 1 | 1]);
  }
  void build(const vector<int> &a) {
    _n = (int)a.size();
    if (_n == 0) return;
    t.assign(_n << 2, info());
    build(1, 0, _n - 1, a);
  }
  void update(int p, info v) {
    update(1, 0, _n - 1, p, v);
  }
  info query(int l, int r) {
    if (_n == 0 || l > r) return info();
    return query(1, 0, _n - 1, l, r);
  }
};
