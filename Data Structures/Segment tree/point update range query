  template<typename T>
  struct SegmentTree {
    vector<T> t;
    int N;
    T def;
    SegmentTree(int _n, T _def) {
      N = _n, def = _def;
      t.assign(N << 2, def);
    }
    T merge(T a, T b) {
      return max(a, b);
    }
    void update(int n, int s, int e, int p, T v) {
      if (s == e) {
        t[n] = v;
        return;
      }
      int m = (s + e) >> 1;
      if (p <= m) update(n << 1, s, m, p, v);
      else update(n << 1 | 1, m + 1, e, p, v);
      t[n] = merge(t[n << 1], t[n << 1 | 1]);
    }
    T query(int n, int s, int e, int l, int r) {
      if (r < s || e < l) return T();
      if (l <= s && e <= r) return t[n];
      int m = (s + e) >> 1;
      return merge(query(n << 1, s, m, l, r), query(n << 1 | 1, m + 1, e, l, r));
    }
    void update(int p, T v) { update(1, 0, N - 1, p, v); }
    T query(int l, int r) {
      if (l > r) return def;
      return query(1, 0, N - 1, l, r);
    }
  };
